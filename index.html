<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Intro to Clojure</title>

		<meta name="description" content="A brief introduction to the Clojure programming language">
		<meta name="author" content="Rafael Guti&eactue;rrez">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Intro to Clojure</h1>
					<h3>A brief introduction to the Clojure programming language</h3>
					<p>
						<small>Created by <a href="https://github.com/abadongutierrez">Rafael Guti&eacute;rrez</a> / <a href="http://twitter.com/abaddon_gtz">@abaddon_gtz</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is Clojure?</h2>					
						<p class="fragment">General Purpose Programming Language</p>
						<p class="fragment">Dynamic</p>
						<p class="fragment">Functional</p>
						<p class="fragment">Lisp</p>
						<p class="fragment">JVM/CRL/Javascript</p>
						<p class="fragment">Homoiconic</p>
						<aside class="notes">
* Clojure is dynamic
	* You can define functions at runtime
	* You can use Clojure as an scripting programming language
	* You can generate clojure code using Macros
						<aside>
					</section>
				</section>

				<section>
					<section>
						<img width="480" height="362" src="http://i.giphy.com/i9nkolRQgbN9C.gif"/>
					</section>
				</section>

				<section>
					<section style="background-color: rgba(255,255,255,0.9);" data-background="http://hypirion.com/imgs/swear-bootstrap.jpg">
						<h4 style="color: orange;">Clojure programs are represented by Clojure data structures</h4>
						<h4 style="color: orange;">Code is data!</h4>
					</section>
				</section>

				<section>
					<h2>REPL</h2>
					<p><span class="fragment">Read</span> <span class="fragment">Evaluate</span> <span class="fragment">Print</span> <span class="fragment">Loop</span></p>
					<div class="fragment">
						<pre><code data-trim contenteditable>
	java -cp clojure.jar clojure.main					
						</code></pre>
						<pre><code data-trim contenteditable>
	user=>					
						</code></pre>
					</div>
					<p class="fragment">But you can <a href="http://www.sublimetext.com/">Sublime</a> and <a href="https://github.com/wuub/SublimeREPL">SublimeREPL</a></p>
					<p class="fragment">Or <a href="http://lighttable.com/">LightTable</a></p>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section data-background="http://java.ociweb.com/mark/clojure/images/ClassDiagram.png">
						<h2 style="background-color: rgba(255,255,255,0.9); color: orange;">Data Types</h2>
					</section>
					<section>
						<h3>Numbers</h3>
						<p>Integers, doubles, floats and fractions</p>
						<pre><code data-trim contenteditable>
user=> 1
user=> 1.0
user=> 1/2
user=> (/ 34 5)
						</code></pre>
						<pre><code data-trim contenteditable>
user=> (int 1)
user=> (long 1)
user=> (float 1)
user=> (double 1)
						</code></pre>
						<pre><code data-trim contenteditable>
user=> (type 1)
user=> (type 1.0)
user=> (type 1/2)
user=> (type (int 1))
user=> (type (long 1))
user=> (type (float 1))
user=> (type (double 1))
						</code></pre>
					</section>
					<section>
						<h3>Booleans</h3>
						<p><code>true</code> and <code>false</code></p>
						<p><code>nil</code> values are evaluated as <code>false</code> (falsey).</p>
						<pre><code data-trim contenteditable>
user=> true
user=> false
user=> (false? nil)
user=> (if nil "true" "false")
						</code></pre>
						<pre><code data-trim contenteditable>
user=> (type true)
user=> (type false)
						</code></pre>
					</section>
					<section>
						<h3>Strings</h3>
						<p>Denoted by double quotes and can span multiple lines</p>
						<pre><code data-trim contenteditable>
user=> "this is a string"
user=> (type "string")
						</code></pre>
					</section>
					<section>
						<h3>Characters</h3>
						<p>Denoted by a forward slash</p>
						<pre><code data-trim contenteditable>
user=> \a
user=> (type \a)
user=> (char 64)
						</code></pre>
					</section>
					<section>
						<h3>Symbols</h3>
						<p>Used to identify variables</p>
						<pre><code data-trim contenteditable>
user=> a
user=> (type a)
user=> (type (quote a))
user=> (type 'a)
user=> (symbol "a")
						</code></pre>
					</section>
					<section>
						<h3>Keywords</h3>
						<p>Symbols that reference themselves and are denoted by a colon ':'; these are often used as keys in maps</p>
						<pre><code data-trim contenteditable>
user=> :a
user=> (type :a)
user=> (keyword "a")
						</code></pre>
					</section>
				</section>

				<section>
					<section data-background="http://www.museumofplay.org/online-collections/images/Z001/Z00150/Z0015004.jpg">
						<h2 style="background-color: rgba(255,255,255,0.9); color: orange;">Collections</h2>
					</section>

					<section>
						<h3>Lists - <code>( )</code></h3>
						<p>Lists are collections of things</p>
						<p>Those things come in a given order</p>
						<pre><code data-trim contenteditable>
user=> (quote (1 :a "item"))
user=> '(1 :a "item")
user=> (list 1 :a "item")
						</code></pre>
						<div class="fragment"?>
							<p>Lists are 'linked' lists</p>
							<pre><code data-trim contenteditable>
user=> (first (list 1 :a "item"))
user=> (rest (list 1 :a "item"))
							</code></pre>
						</div>
						<div class="fragment"?>
							<p><code>nil</code> is the end of the list</p>
							<pre><code data-trim contenteditable>
user=> (first (rest (rest (rest (list 1 :a "item")))))
							</code></pre>
						</div>
						<div class="fragment"?>
							<p>Building a list</p>
							<pre><code data-trim contenteditable>
user=> (cons :item '())
user=> (cons 1 nil)
user=> (cons "string" (cons :item (cons 5 nil)))
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Vectors - <code>[ ]</code></h3>
						<p>Like 'arrays' because they have index access</p>
						<pre><code data-trim contenteditable>
user=> [1 :item "string"]
user=> (first [1 :item "string"])
user=> (rest [1 :item "string"])
						</code></pre>
					<div class="fragment"?>	
						<p>Access by index</p>
						<pre><code data-trim contenteditable>
user=> (nth [1 :item "string"] 2)
						</code></pre>
					</div>
					<div class="fragment"?>	
						<p>Building a vector</p>
						<pre><code data-trim contenteditable>
user=> (cons 1/2 [1 :item "string"])
user=> (vector (cons 1/2 [1 :item "string"]))
						</code></pre>
					</div>
					<div class="fragment"?>	
						<p>Using conj[oin] function</p>
						<pre><code data-trim contenteditable>
user=> (conj [1 :item "string"] 1/2)
user=> (conj '(1 :item "string") 1/2)
						</code></pre>
					</div>
					</section>
					<section>
						<h3>Maps - <code>{ }</code></h3>
						<p>Key-value pairs of data</p>
						<pre><code data-trim contenteditable>
user=> {:name "Your name" :last-name "Your lastname"}
						</code></pre>
						<div class="fragment"?>	
							<p>Getting a value</p>
							<pre><code data-trim contenteditable>
user=> (get {:name "tomato" :price 1.25} :price)
user=> (get {:name "tomato" :price 1.25} :weight "Not found")
user=> (:price {:name "tomato" :price 1.25})
							</code></pre>
						</div>
						<div class="fragment"?>	
							<p>Building a Map</p>
							<pre><code data-trim contenteditable>
user=> (assoc {:name "tomato" :price 1.25} :weight {:quantity 4 :unit :ounces})
user=> (dissoc {:name "tomato" :price 1.25 :weight {:quantity 4 :unit :ounces}} :name)
user=> (merge {:name "tomato"} {:price 1.25} {:weight {:quantity 4 :unit :ounces}})
							</code></pre>
						</div>
						<div class="fragment"?>	
							<p>Values and Keys</p>
							<pre><code data-trim contenteditable>
user=> (keys {:name "tomato" :price 1.25})
user=> (vals {:name "tomato" :price 1.25})
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Sets - <code>#{ }</code></h3>
						<p>Collections of elements with no duplicates</p>
						<pre><code data-trim contenteditable>
user=> #{:apple :banana :melon :blue-berry :apple}
user=> #{:apple :banana :melon :blue-berry}
						</code></pre>
						<div class="fragment"?>	
							<p>Getting a value</p>
							<pre><code data-trim contenteditable>
user=> (get #{:apple :banana :melon :blue-berry} :banana)
user=> (#{:apple :banana :melon :blue-berry} :banana)
							</code></pre>
						</div>
						<div class="fragment"?>	
							<p>Building a Set</p>
							<pre><code data-trim contenteditable>
user=> (conj #{:apple :banana :melon :blue-berry} :black-berry)
user=> (disj #{:apple :banana :melon :blue-berry} :melon)
							</code></pre>
						</div>
						<div class="fragment"?>	
							<p>Interesting operations</p>
							<pre><code data-trim contenteditable>
user=> (clojure.set/union #{:r :b :w} #{:w :p :y})
user=> (clojure.set/difference #{:r :b :w} #{:w :p :y})
user=> (clojure.set/intersection #{:r :b :w} #{:w :p :y})
							</code></pre>
						</div>
					</section>
				</section>

				<section>
					<h2>Binding symbols to values</h2>
					<p>
						Clojure symbols refer to values.
					</p>
					<pre><code data-trim contenteditable>
user=> (def my-vector [1 2 3])
					</code></pre>
					<div class="fragment"?>
						<p>What if I dont need a temporary var?</p>
						<pre><code data-trim contenteditable>
user=> (let [msg "Say Hello"] (println msg))
					</code></pre>
					</div>
					<div class="fragment"?>
						<p>What happens in <code>let</code>, stays in <code>let</code></p>
						<pre><code data-trim contenteditable>
user=> (def my-number 1)
user=> (let [my-number 2] (println my-number))
					</code></pre>
					</div>
				</section>

				<section>
					<h2>Functions</h2>
					<p>
						Declaring a funcion with <code>fn</code>
					</p>
					<pre><code data-trim contenteditable>
user=> (fn [])
user=> ((fn []))
user=> ((fn [] "Hello"))
user=> (def say-hello (fn [] "Hello"))
user=> (say-hello)
user=> #("Hello")
user=> (#("Hello"))
user=> (#(str "Hello"))
					</code></pre>
					<div class="fragment"?>
						<p>Using <code>defn</code></p>
						<pre><code data-trim contenteditable>
user=> (defn sum [a b] (+ a b))
user=> (sum 1 2)
					</code></pre>
					</div>
				</section>

				<section>
					<h2>Namespaces</h2>
					<p>
						To keep everything organized and group similar funtionality
					</p>
					<pre><code data-trim contenteditable>
user=> (ns com.nearsoft)
com.nearsoft=> (def my-email "rgutierrez@nearsoft.com")
com.nearsoft=> my-email
com.nearsoft=> com.nearsoft/my-email
com.nearsoft=> *ns*
com.nearsoft=> (ns user)
user=> com.nearsoft/my-email
					</code></pre>
					<div class="fragment"?>
						<p>Accesing symbols in namespaces with <code>require</code></p>
						<pre><code data-trim contenteditable>
user=> (require 'com.nearsoft)
user=> (require '[com.nearsoft :as ns])
user=> (require '[com.nearsoft :refer [my-email]])
user=> (require '[com.nearsoft :refer :all)
					</code></pre>
					</div>
					<div class="fragment"?>
						<p>Using <code>require</code> inside <code>ns</code></p>
						<pre><code data-trim contenteditable>
user=> (ns com.acme
		(:require [com.nearsoft :refer :all]))
com.acme=> my-email
					</code></pre>
					</div>
				</section>

				<section>
					<section data-background="http://www.dickey-john.com/_media/pw_a_LiquidFlowControlValves.jpg">
						<h2 style="background-color: rgba(255,255,255,0.9); color: orange;">Flow Control</h2>
					</section>

					<section>
						<h3><code>if</code></h3>
						<p>Takes three params: logical test, expression to be evaluated when logical test is true, and expression if logical test is false</p>
						<pre><code data-trim contenteditable>
user=> (if true "This is true" "This is false")
user=> (if false "This is true" "This is false")
user=> (if (= :beer (keyword "beer")) "Lets drink!" "Dont drink!")
						</code></pre>
						<div class="fragment"?>
							<p>What about <code>nil</code>?</p>
							<pre><code data-trim contenteditable>
user=> (if nil "This is true" "This is false")
							</code></pre>
						</div>
					</section>

					<section>
						<h3><code>if-let</code></h3>
						<p>Sames as <code>if</code> but also allows you to bind an expression to a symbol and use it ONLY WHEN IT IS TRUE.</p>
						<pre><code data-trim contenteditable>
user=> (if-let [logical-value true]
           (println (str "true is " logical-value))
           (println (str "false is " logical-value)))
user=> (if-let [logical-value true]
           (println (str "true is " logical-value))
           (println (str "This is false")))
						</code></pre>
					</section>

					<section>
						<h3><code>when</code></h3>
						<p>If the predicate is true, evaluates the body. Otherwise, it returns nil.</p>
						<pre><code data-trim contenteditable>
user=> (when (= 5 (+ 2 3)) "Its a five!")
						</code></pre>
					</section>

					<section>
						<h3><code>when-let</code></h3>
						<p>Exactly same idea as if-let</p>
						<pre><code data-trim contenteditable>
user=> (defn drop-first
           [coll]
           (when-let [s (seq coll)]
               (rest s)))
user=> (drop-first [1 2 3])
user=> (drop-first [])
						</code></pre>
					</section>

					<section>
						<h3><code>cond</code></h3>
						<p>What if we want to test multiple things?</p>
						<pre><code data-trim contenteditable>
user=> (defn buy-a-beer?
           [price]
           (if (> price 5)
               "Its expensive!"
               (if (< price 5)
                   "Nah, I can buy a better beer"
                   (if (= price 5)
                       "Shut up and take my money!"))))
user=> (defn buy-a-beer-cond?
           [price]
           (cond
               (> price 5) "Its expensive!"
               (< price 5) "Nah, I can buy a better beer"
               (= price 5) "Shut up and take my money!"))
						</code></pre>
						<div class="fragment"?>
							<p>Warning: The order of the test are important</p>
						</div>
						<div class="fragment"?>
							<p>Default clause? Add :else at the end</p>
							<pre><code data-trim contenteditable>
user=> (defn buy-a-beer-cond?
           [price]
           (cond
               (> price 5) "Its expensive!"
               (< price 5) "Nah, I can buy a better beer"
               :else "Shut up and take my money!"))
							</code></pre>
						</div>
					</section>

					<section>
						<h3><code>case</code></h3>
						<p>Shortcut for cond when there is only one test value and it can be compared using =</p>
						<pre><code data-trim contenteditable>
user=> (defn should-drink?
           [beverage]
           (case beverage
               "beer" "Yeah, go ahead"
               "wine" "A little"
               "rum" "hmm, I pass"
               "I dont know"))
 user=> (should-drink? "beer")
 user=> (should-drink? "tequila")
						</code></pre>

					</section>
				</section>

				<section>
					<h2>What is next?</h2>
					<p  class="fragment">High Order Functions</p>
					<p  class="fragment">Sequence Comprehensions</p>
					<p  class="fragment">Destructuring</p>
					<p  class="fragment">Recursion</p>
					<p  class="fragment">Java Interop</p>
					<p  class="fragment">Macros</p>
					<p  class="fragment">Concurrency</p>
				</section>

				<section>
					<h2>Thanks!</h2>
				</section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
